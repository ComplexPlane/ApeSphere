# Code created by PistonMiner and Zephiles

# 8006FE38 -- Address to hook for this code

# Use the following line to branch to this code
# b -0x6B8B0 # -- 0x6FE38-0x4588

# Initialize static values used for addresses
lis r31,0x8000

li r30,0 # Used to check if a REL file is loaded or not

# Check if a Memory Card is present
# To avoid an infinite loop, only check for a memory card a set amount of times
lis r29,0x000F
ori r29,r29,0x4240 # Check 1,000,000 times

checkForMemoryCardLoop:
li r3,0 # Memory Card Slot A
li r4,0 # Pointer to the Memory Size (Not needed, so NULL)
li r5,0 # Pointer to the Sector Size (Not needed, so NULL)
bl 0x2AAFF0 # CARDProbeEx -- 0x45A4
cmpwi r3,-1 # CARD_RESULT_BUSY
bne- exitCheckForMemoryCardLoop

# Exit if the limit has been reached
subic. r29,r29,1
bgt+ checkForMemoryCardLoop
b exit

exitCheckForMemoryCardLoop:
cmpwi r3,0 # Check if something went wrong
bne- exit

# Mount the Memory Card
li r3,0 # Memory Card Slot A
lwz r4,0x1B98(r13)
lwz r4,0x4(r4) # Pointer to the Work Area
li r5,0 # Detach Callback function (Want to avoid using, so NULL)
li r6,0 # Attach Callback function (Want to avoid using, so NULL)
bl 0x2AB6C4 # CARDMountAsync -- 0x45D8
bl finishAsyncFunction
cmpwi r3,0 # Check if something went wrong
bne- exit

# Allocate memory for CardFileInfo
li r4,20
bl allocateMemory

# Backup the returned address to be used for later
mr r29,r3

# Open the file
li r3,0 # Memory Card Slot A
ori r4,r31,0x40DC # File Name
mr r5,r29 # Pointer to CardFileInfo
bl 0x2AC5DC # CARDOpen -- 0x4600
cmpwi r3,0 # Check if something went wrong
bne- freeCardFileInfo

# Allocate 0x200 bytes of memory, as the read size must be in multiples of 0x200 bytes
li r4,0x200 # Bytes to allocate
bl allocateMemory

# Backup the returned address to be used for later
mr r27,r3

# Read from the Card
mr r3,r29 # Pointer to CardFileInfo
mr r4,r27 # Pointer to the File Buffer
li r5,0x200 # Amount of bytes to read
li r6,0x2000 # Offset in the file to start reading from
li r7,0 # Read Callback function (Want to avoid using, so NULL)
bl 0x2ACD60 # CARDReadAsync -- 0x462C
bl finishAsyncFunction
cmpwi r3,0 # Check if something went wrong
bne- freeCurrentMemoryArea

# Get the file size and adjust it to be in multiples of 0x200 bytes
lwz r28,0x40(r27) # File Size
addi r28,r28,511
rlwinm r28,r28,0,0,22

# Free the 0x200 bytes from earlier
mr r4,r27
bl freeMemory

# Allocate more bytes based on the adjusted file size
mr r4,r28
bl allocateMemory

# Backup the returned address to be used for later
mr r27,r3

# Read the REL Area of the file
mr r3,r29 # Pointer to CardFileInfo
mr r4,r27 # Pointer to the File Buffer
mr r5,r28 # Adjusted File Size
li r6,0x2200 # Offset in the file to start reading from
li r7,0 # Read Callback Function (Want to avoid using, so NULL)
bl 0x2ACD1C # CARDReadAsync -- 0x4670
bl finishAsyncFunction
cmpwi r3,0 # Check if something went wrong
bne- freeCurrentMemoryArea

# Get the BSS Area size and allocate memory for it
lwz r4,0x20(r27)
bl allocateMemory

# Backup the returned address to be used for later
mr r28,r3

# Link the functions in the REL
mr r3,r27 # Pointer to the Module
mr r4,r28 # Pointer to the BSS Area
bl 0x296250 # OSLink -- 0x4694
cmpwi r3,1 # Check if something went wrong
bne- freeRemainingMemory

# Store the BSS Area and the Module
stw r28,0x414C(r31) # Pointer to the BSS Area
stw r27,0x4150(r31) # Pointer to the Module

# Get the REL Prolog Pointer
lwz r30,0x34(r27)

# Done, so close and unmount the card
b closeCard

# Function definitions, error handling, etc.
freeMemory:
li r3,0 # Heap to use
b 0x2BA10 # __memFree -- 0x46B4

allocateMemory:
li r3,0 # Heap to use
b 0x2BA34 # __memAlloc -- 0x46BC

finishAsyncFunction:
cmpwi r3,0 # Check if something went wrong
bnelr-
mflr r14

finishAsyncFunctionLoop:
li r3,0 # Memory Card Slot A
bl 0x2A8074 # CARDGetResultCode -- 0x46D0
cmpwi r3,-1 # CARD_RESULT_BUSY
beq+ finishAsyncFunctionLoop
mtlr r14
blr

freeRemainingMemory:
mr r3,r27 # Pointer to the Module
bl 0x296458 # OSUnlink -- 0x46E8

# Free the BSS Area and the File Buffer
mr r4,r28 # Pointer to the BSS Area
bl freeMemory

freeCurrentMemoryArea:
mr r4,r27 # Pointer to the File Buffer or the 0x200 Bytes Buffer
bl freeMemory

closeCard:
mr r3,r29 # Pointer to CardFileInfo
bl 0x2AC5F8 # CARDClose -- 0x4700

freeCardFileInfo:
mr r4,r29
bl freeMemory

# Unmount the Memory Card
li r3,0 # Memory Card Slot A
bl 0x2AB7C8 # CARDUnmount -- 0x4710

# Run the REL Prolog if the load was successful
cmpwi r30,0
beq- exit
mtlr r30
blrl

exit:
# Add back in the overwritten instruction
li r3,0

# Branch back to hooked function
b 0x6B714 # 8006FE3C -- 0x4728